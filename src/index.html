<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MiniML - Predictive Quality Control</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/rxjs/7.8.1/rxjs.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f7fa;
            color: #333;
        }

        .header {
            background: linear-gradient(135deg, #ff4444 0%, #cc3366 50%, #9966cc 100%);
            color: white;
            padding: 16px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 18px;
            font-weight: 500;
        }

        .header .subtitle {
            font-size: 12px;
            opacity: 0.9;
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            letter-spacing: -1px;
        }

        .progress-container {
            background: white;
            padding: 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .step-indicator {
            display: flex;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }

        .step {
            flex: 1;
            display: flex;
            align-items: center;
            padding: 12px 16px;
            border-right: 1px solid #e9ecef;
            font-size: 14px;
            position: relative;
        }

        .step:last-child {
            border-right: none;
        }

        .step.active {
            background: #e8f5e8;
            color: #2d5a2d;
        }

        .step.disabled {
            color: #999;
        }

        .step-number {
            background: #28a745;
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 8px;
            font-size: 12px;
            font-weight: bold;
        }

        .step.disabled .step-number {
            background: #ccc;
        }

        .current-step {
            background: white;
            padding: 24px;
            min-height: 500px;
        }

        .step-title {
            color: #666;
            font-size: 14px;
            margin-bottom: 8px;
        }

        .step-counter {
            background: #007bff;
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
            float: right;
        }

        .upload-area {
            border: 2px dashed #d1d5db;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            background: #fafafa;
            margin: 20px 0;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-area:hover {
            border-color: #007bff;
            background: #f8f9ff;
        }

        .upload-area.dragover {
            border-color: #007bff;
            background: #e8f4ff;
            transform: scale(1.02);
        }

        .upload-icon {
            width: 48px;
            height: 48px;
            margin: 0 auto 16px;
            opacity: 0.5;
        }

        .upload-text {
            color: #666;
            font-size: 16px;
            margin-bottom: 16px;
        }

        .choose-file-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .choose-file-btn:hover {
            background: #0056b3;
        }

        .choose-file-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .file-input {
            display: none;
        }

        .summary-card {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-top: 16px;
        }

        .summary-item {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 6px;
            border-left: 4px solid #007bff;
        }

        .summary-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .summary-value {
            font-size: 16px;
            font-weight: 600;
            color: #333;
        }

        .summary-value.link {
            color: #007bff;
            cursor: pointer;
            text-decoration: underline;
        }

        .next-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 32px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            float: right;
            margin-top: 20px;
            transition: background 0.3s ease;
        }

        .next-btn:hover:not(:disabled) {
            background: #0056b3;
        }

        .next-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        /* Date Ranges Screen Styles */
        .date-ranges-container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .periods-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .period-card {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .period-card h3 {
            color: #333;
            font-size: 16px;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
        }

        .period-icon {
            width: 20px;
            height: 20px;
            margin-right: 8px;
            border-radius: 3px;
        }

        .period-icon.training {
            background: #28a745;
        }

        .period-icon.testing {
            background: #ffc107;
        }

        .period-icon.simulation {
            background: #007bff;
        }

        .date-input-group {
            margin-bottom: 12px;
        }

        .date-input-group label {
            display: block;
            font-size: 12px;
            color: #666;
            margin-bottom: 4px;
            text-transform: uppercase;
        }

        .date-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .date-input:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
        }

        .validation-message {
            margin: 20px 0;
            padding: 12px;
            border-radius: 6px;
            font-size: 14px;
        }

        .validation-message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .validation-message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .validation-message .icon {
            margin-right: 8px;
        }

        .range-summary-section {
            margin: 30px 0;
        }

        .range-summary-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 16px;
            margin: 16px 0;
        }

        .range-summary-card {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 16px;
            text-align: center;
        }

        .range-summary-card h4 {
            color: #666;
            font-size: 12px;
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .range-summary-card .duration {
            font-size: 24px;
            font-weight: bold;
            color: #333;
            margin-bottom: 4px;
        }

        .range-summary-card .dates {
            font-size: 12px;
            color: #666;
        }

        .timeline-chart-container {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .timeline-chart-container h3 {
            margin-bottom: 16px;
            color: #333;
            font-size: 16px;
        }

        .chart-container {
            position: relative;
            height: 300px;
        }

        .action-buttons {
            margin-top: 30px;
            text-align: right;
        }

        .validate-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            margin-right: 12px;
            transition: background 0.3s ease;
        }

        .validate-btn:hover {
            background: #218838;
        }

        .validate-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .footer {
            background: linear-gradient(135deg, #ff4444 0%, #9966cc 100%);
            color: white;
            text-align: center;
            padding: 12px;
            font-size: 12px;
            font-weight: 500;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
        }

        .hidden {
            display: none;
        }
        /* Add these CSS styles to your existing stylesheet */

        /* Model Training Screen Styles */
        .model-training-container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .training-section {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 200px;
            margin: 40px 0;
        }

        .training-button-container {
            text-align: center;
        }

        .train-model-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 16px 40px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,123,255,0.3);
        }

        .train-model-btn:hover:not(:disabled) {
            background: #0056b3;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,123,255,0.4);
        }

        .train-model-btn:disabled {
            cursor: not-allowed;
            transform: none;
        }

        .training-results {
            margin-top: 30px;
        }

        .training-status {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 30px;
            display: flex;
            align-items: center;
            font-weight: 500;
        }

        .status-icon {
            background: #28a745;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            font-size: 14px;
        }

        .metrics-section {
            margin: 30px 0;
        }

        .metrics-section h3 {
            color: #333;
            font-size: 18px;
            margin-bottom: 20px;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 16px;
        }

        .metric-card {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 24px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            position: relative;
            overflow: hidden;
        }

        .metric-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
        }

        .metric-card.accuracy::before {
            background: linear-gradient(90deg, #4c6ef5 0%, #7c3aed 100%);
        }

        .metric-card.precision::before {
            background: linear-gradient(90deg, #ec4899 0%, #f97316 100%);
        }

        .metric-card.recall::before {
            background: linear-gradient(90deg, #06b6d4 0%, #10b981 100%);
        }

        .metric-card.f1-score::before {
            background: linear-gradient(90deg, #10b981 0%, #84cc16 100%);
        }

        .metric-value {
            font-size: 32px;
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
        }

        .metric-label {
            font-size: 14px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .metrics-note {
            font-size: 12px;
            color: #666;
            font-style: italic;
            text-align: center;
            margin-top: 16px;
        }

        .charts-section {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            margin: 30px 0;
        }

        .chart-card {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .chart-card h3 {
            color: #333;
            font-size: 16px;
            margin-bottom: 4px;
        }

        .chart-subtitle {
            color: #666;
            font-size: 14px;
            margin-bottom: 20px;
        }

        .chart-container {
            position: relative;
            height: 300px;
            margin-top: 16px;
        }

        .confusion-matrix-container {
            position: relative;
            height: 300px;
            margin-top: 16px;
        }

        /* Responsive adjustments */
        @media (max-width: 1000px) {
            .charts-section {
                grid-template-columns: 1fr;
            }
            
            .metrics-grid {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            }
        }

        @media (max-width: 768px) {
            .train-model-btn {
                padding: 14px 32px;
                font-size: 14px;
            }
            
            .metric-value {
                font-size: 24px;
            }
            
            .chart-container,
            .confusion-matrix-container {
                height: 250px;
            }
        }
        /* Simulation Screen Styles */
        .simulation-container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .simulation-section {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 200px;
            margin: 40px 0;
        }

/* ... rest of the simulation CSS styles ... */
    </style>
</head>
<body>
    <div id="app">
        <!-- Header -->
        <div class="header">
            <div>
                <h1>MiniML - Predictive Quality Control</h1>
                <div class="subtitle">Simplified Frontend</div>
            </div>
            <div class="logo">ABB</div>
        </div>

        <!-- Progress Steps -->
        <div class="progress-container">
            <div class="step-indicator">
                <div class="step active" data-step="0">
                    <div class="step-number">1</div>
                    <span>Upload Dataset</span>
                </div>
                <div class="step disabled" data-step="1">
                    <div class="step-number">2</div>
                    <span>Date Ranges</span>
                </div>
                <div class="step disabled" data-step="2">
                    <div class="step-number">3</div>
                    <span>Model Training</span>
                </div>
                <div class="step disabled" data-step="3">
                    <div class="step-number">4</div>
                    <span>Simulation</span>
                </div>
            </div>
        </div>

        <!-- Current Step Content -->
        <div class="current-step" id="currentStepContent">
            <!-- Step 1 content will be here initially -->
        </div>

        <!-- Footer -->
        <div class="footer">
            ENGINEERED TO OUTRUN
        </div>
    </div>

    <script>
        class MiniMLApp {
            constructor() {
                this.currentStep = 0;
                this.uploadedFile = null;
                this.fileData = null;
                this.trainingChart = null;
                this.confusionChart = null;
                this.qualityChart = null;
                this.confidenceChart = null;
                this.simulationInterval = null;
                this.qualityData = null;
                this.confidenceData = null;
                this.simulationStats = null;
                this.dateRanges = {
                    training: { start: '', end: '' },
                    testing: { start: '', end: '' },
                    simulation: { start: '', end: '' }
                };
                this.isValidated = false;
                this.dailyCounts = [];
                this.initializeApp();
            }

            // Deprecated: generateMockDataset removed; using backend daily counts instead

            initializeApp() {
                this.renderStep();
                this.initializeStepIndicators();
            }

            initializeStepIndicators() {
                const steps = document.querySelectorAll('.step');
                steps.forEach((step, index) => {
                    step.addEventListener('click', () => {
                        if (index <= this.currentStep || (index === 1 && this.uploadedFile)) {
                            this.currentStep = index;
                            this.updateStepDisplay();
                            this.renderStep();
                        }
                    });
                });
            }

            updateStepDisplay() {
                const steps = document.querySelectorAll('.step');
                steps.forEach((step, index) => {
                    step.classList.remove('active', 'disabled');
                    if (index === this.currentStep) {
                        step.classList.add('active');
                    } else if (index > this.currentStep && !(index === 1 && this.uploadedFile)) {
                        step.classList.add('disabled');
                    }
                });
            }

            renderStep() {
                const content = document.getElementById('currentStepContent');
                
                switch (this.currentStep) {
                    case 0:
                        this.renderUploadStep(content);
                        break;
                    case 1:
                        this.renderDateRangesStep(content);
                        break;
                    case 2:
                        this.renderModelTrainingStep(content);
                        break;
                    case 3:
                        this.renderSimulationStep(content);
                        break;
                    default:
                        this.renderPlaceholderStep(content);
                        break;
                }
            }

            renderUploadStep(content) {
                content.innerHTML = `
                    <div class="step-title">Upload Dataset</div>
                    <div class="step-counter">Step 1 of 4</div>
                    
                    <div class="upload-area" id="uploadArea">
                        <svg class="upload-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M14 2H6C4.9 2 4 2.9 4 4V20C4 21.1 4.9 22 6 22H18C19.1 22 20 21.1 20 20V8L14 2Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <polyline points="14,2 14,8 20,8" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <line x1="16" y1="13" x2="8" y2="13" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <line x1="16" y1="17" x2="8" y2="17" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <polyline points="10,9 9,9 9,10" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                        <div class="upload-text">Click to select a CSV file or drag and drop</div>
                        <button class="choose-file-btn" id="chooseFileBtn">Choose File</button>
                        <input type="file" class="file-input" id="fileInput" accept=".csv">
                    </div>

                    <div class="summary-card hidden" id="summaryCard">
                        <h3>Post-upload Info Summary Card</h3>
                        <div class="summary-grid" id="summaryGrid"></div>
                    </div>

                    <button class="next-btn" id="nextBtn" ${!this.uploadedFile ? 'disabled' : ''}>Next</button>
                `;

                this.initializeUploadListeners();
            }

            initializeUploadListeners() {
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');
                const chooseFileBtn = document.getElementById('chooseFileBtn');
                const nextBtn = document.getElementById('nextBtn');

                fileInput.addEventListener('change', (e) => this.handleFileSelect(e));
                chooseFileBtn.addEventListener('click', () => fileInput.click());
                uploadArea.addEventListener('dragover', (e) => this.handleDragOver(e));
                uploadArea.addEventListener('dragleave', (e) => this.handleDragLeave(e));
                uploadArea.addEventListener('drop', (e) => this.handleDrop(e));
                uploadArea.addEventListener('click', () => fileInput.click());
                nextBtn.addEventListener('click', () => this.nextStep());
            }

            handleDragOver(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.add('dragover');
            }

            handleDragLeave(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.remove('dragover');
            }

            handleDrop(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0 && files[0].type === 'text/csv') {
                    this.processFile(files[0]);
                }
            }

            handleFileSelect(e) {
                const file = e.target.files[0];
                if (file) {
                    this.processFile(file);
                }
            }

            async processFile(file) {
                this.uploadedFile = file;

                const formData = new FormData();
                formData.append("file", file);

                try {
                    const response = await fetch("http://localhost:5000/api/upload", {
                        method: "POST",
                        body: formData
                    });

                    if (!response.ok) {
                        throw new Error(`Upload failed: ${response.statusText}`);
                    }

                    const data = await response.json();
                    this.showSummaryCard(data);  // pass backend JSON
                    document.getElementById('nextBtn').disabled = false;
                } catch (error) {
                    alert("Error uploading file: " + error.message);
                    console.error(error);
                }
            }

            showSummaryCard(data) {
                const summaryCard = document.getElementById('summaryCard');
                const summaryGrid = document.getElementById('summaryGrid');
                const fileName = data.fileName || data.FileName || '';
                const totalRecords = data.totalRecords || data.TotalRecords || 0;
                const totalColumns = data.totalColumns || data.TotalColumns || 0;
                const passRate = data.passRate ?? data.PassRate ?? 0;
                const startTs = (data.startTimestamp || data.StartTimestamp || '').toString();
                const endTs = (data.endTimestamp || data.EndTimestamp || '').toString();
                const startDateStr = startTs ? startTs.split('T')[0] : '';
                const endDateStr = endTs ? endTs.split('T')[0] : '';
                // Save bounds for date inputs
                this.datasetBounds = { min: startDateStr, max: endDateStr };
                
                summaryGrid.innerHTML = `
                    <div class="summary-item">
                        <div class="summary-label">File Name</div>
                        <div class="summary-value link">${fileName}</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-label">Total Records</div>
                        <div class="summary-value">${totalRecords}</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-label">Total Columns</div>
                        <div class="summary-value">${totalColumns}</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-label">Pass Rate</div>
                        <div class="summary-value">${(Number(passRate) * 100).toFixed(1)}%</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-label">Date Range</div>
                        <div class="summary-value">${startDateStr} to ${endDateStr}</div>
                    </div>
                `;
                
                summaryCard.classList.remove('hidden');
            }


            renderDateRangesStep(content) {
                content.innerHTML = `
                    <div class="step-title">Date Ranges</div>
                    <div class="step-counter">Step 2 of 4</div>
                    
                    <div class="date-ranges-container">
                        <div class="periods-grid">
                            <div class="period-card">
                                <h3><div class="period-icon training"></div>Training Period</h3>
                                <div class="date-input-group">
                                    <label>Start Date</label>
                                    <input type="date" class="date-input" id="trainingStart" min="${(this.datasetBounds && this.datasetBounds.min) || '2021-01-01'}" max="${(this.datasetBounds && this.datasetBounds.max) || '2021-12-31'}" value="${this.dateRanges.training.start}">
                                </div>
                                <div class="date-input-group">
                                    <label>Start Time</label>
                                    <input type="time" class="date-input" id="trainingStartTime" value="${this.dateRanges.training.startTime || '00:00'}">
                                </div>
                                <div class="date-input-group">
                                    <label>End Date</label>
                                    <input type="date" class="date-input" id="trainingEnd" min="${(this.datasetBounds && this.datasetBounds.min) || '2021-01-01'}" max="${(this.datasetBounds && this.datasetBounds.max) || '2021-12-31'}" value="${this.dateRanges.training.end}">
                                </div>
                                <div class="date-input-group">
                                    <label>End Time</label>
                                    <input type="time" class="date-input" id="trainingEndTime" value="${this.dateRanges.training.endTime || '23:59'}">
                                </div>
                            </div>
                            
                            <div class="period-card">
                                <h3><div class="period-icon testing"></div>Testing Period</h3>
                                <div class="date-input-group">
                                    <label>Start Date</label>
                                    <input type="date" class="date-input" id="testingStart" min="${(this.datasetBounds && this.datasetBounds.min) || '2021-01-01'}" max="${(this.datasetBounds && this.datasetBounds.max) || '2021-12-31'}" value="${this.dateRanges.testing.start}">
                                </div>
                                <div class="date-input-group">
                                    <label>Start Time</label>
                                    <input type="time" class="date-input" id="testingStartTime" value="${this.dateRanges.testing.startTime || '00:00'}">
                                </div>
                                <div class="date-input-group">
                                    <label>End Date</label>
                                    <input type="date" class="date-input" id="testingEnd" min="${(this.datasetBounds && this.datasetBounds.min) || '2021-01-01'}" max="${(this.datasetBounds && this.datasetBounds.max) || '2021-12-31'}" value="${this.dateRanges.testing.end}">
                                </div>
                                <div class="date-input-group">
                                    <label>End Time</label>
                                    <input type="time" class="date-input" id="testingEndTime" value="${this.dateRanges.testing.endTime || '23:59'}">
                                </div>
                            </div>
                            
                            <div class="period-card">
                                <h3><div class="period-icon simulation"></div>Simulation Period</h3>
                                <div class="date-input-group">
                                    <label>Start Date</label>
                                    <input type="date" class="date-input" id="simulationStart" min="${(this.datasetBounds && this.datasetBounds.min) || '2021-01-01'}" max="${(this.datasetBounds && this.datasetBounds.max) || '2021-12-31'}" value="${this.dateRanges.simulation.start}">
                                </div>
                                <div class="date-input-group">
                                    <label>Start Time</label>
                                    <input type="time" class="date-input" id="simulationStartTime" value="${this.dateRanges.simulation.startTime || '00:00'}">
                                </div>
                                <div class="date-input-group">
                                    <label>End Date</label>
                                    <input type="date" class="date-input" id="simulationEnd" min="${(this.datasetBounds && this.datasetBounds.min) || '2021-01-01'}" max="${(this.datasetBounds && this.datasetBounds.max) || '2021-12-31'}" value="${this.dateRanges.simulation.end}">
                                </div>
                                <div class="date-input-group">
                                    <label>End Time</label>
                                    <input type="time" class="date-input" id="simulationEndTime" value="${this.dateRanges.simulation.endTime || '23:59'}">
                                </div>
                            </div>
                        </div>
                        
                        <div id="validationMessage"></div>
                        
                        <div class="range-summary-section" id="rangeSummarySection" style="display: none;">
                            <h3>Selected Date Ranges Summary</h3>
                            <div class="range-summary-cards" id="rangeSummaryCards"></div>
                        </div>
                        
                        <div class="timeline-chart-container" id="timelineChart" style="display: none;">
                            <h3>Timeline Summary</h3>
                            <div class="chart-container">
                                <canvas id="timelineCanvas"></canvas>
                            </div>
                        </div>
                        
                        <div class="action-buttons">
                            <button class="validate-btn" id="validateBtn">Validate Ranges</button>
                            <button class="next-btn" id="nextBtn" ${!this.isValidated ? 'disabled' : ''}>Next</button>
                        </div>
                    </div>
                `;

                this.initializeDateRangeListeners();
            }

            // Add this method to your MiniMLApp class, replacing the renderPlaceholderStep method

            renderModelTrainingStep(content) {
                content.innerHTML = `
                    <div class="step-title">Model Training & Evaluation</div>
                    <div class="step-counter">Step 3 of 4</div>
                    
                    <div class="model-training-container">
                        <div class="training-section" id="trainingSection">
                            <div class="training-button-container">
                                <button class="train-model-btn" id="trainModelBtn">Train Model</button>
                            </div>
                        </div>
                        
                        <div class="training-results hidden" id="trainingResults">
                            <div class="training-status" id="trainingStatus">
                                <div class="status-icon">✓</div>
                                <span>Model Trained Successfully!</span>
                            </div>
                            
                            <div class="metrics-section">
                                <h3>Model Performance Metrics</h3>
                                <div class="metrics-grid" id="metricsGrid">
                                    <!-- Metrics will be populated here -->
                                </div>
                                <div class="metrics-note" id="trainingInfo">
                                    *Model training in progress...
                                </div>
                            </div>
                            
                            <div class="charts-section">
                                <div class="chart-card">
                                    <h3>Model Performance</h3>
                                    <div class="chart-subtitle">Training Metrics</div>
                                    <div class="chart-container">
                                        <canvas id="trainingChart"></canvas>
                                    </div>
                                </div>
                                
                                <div class="chart-card">
                                    <h3>Model Performance</h3>
                                    <div class="chart-subtitle">Confusion Matrix</div>
                                    <div class="confusion-matrix-container">
                                        <canvas id="confusionChart"></canvas>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <button class="next-btn" id="nextBtn" disabled>Next</button>
                `;

                this.initializeModelTrainingListeners();
            }

            renderSimulationStep(content) {
                content.innerHTML = `
                    <div class="step-title">Real-Time Prediction Simulation</div>
                    <div class="step-counter">Step 4 of 4</div>

                    <div class="simulation-container">
                        <div class="simulation-section">
                            <button class="train-model-btn" id="startSimulationBtn">Start Simulation</button>
                        </div>

                        <div id="simulationStatus" class="training-status hidden"><div class="status-icon">✓</div><span>✔ Simulation completed</span></div>

                        <div class="charts-section">
                            <div class="chart-card">
                                <h3>Quality Scores Over Time</h3>
                                <div class="chart-subtitle">Real-time</div>
                                <div class="chart-container"><canvas id="qualityChart"></canvas></div>
                            </div>
                            <div class="chart-card">
                                <h3>Prediction Confidence Distribution</h3>
                                <div class="chart-subtitle">Pass vs Fail</div>
                                <div class="chart-container"><canvas id="confidenceChart"></canvas></div>
                            </div>
                        </div>

                        <div class="summary-card">
                            <h3>Statistics</h3>
                            <div class="summary-grid">
                                <div class="summary-item"><div class="summary-label">Total Predictions</div><div class="summary-value" id="statTotal">0</div></div>
                                <div class="summary-item"><div class="summary-label">Pass Count</div><div class="summary-value" id="statPass">0</div></div>
                                <div class="summary-item"><div class="summary-label">Fail Count</div><div class="summary-value" id="statFail">0</div></div>
                                <div class="summary-item"><div class="summary-label">Average Confidence</div><div class="summary-value" id="statAvg">0%</div></div>
                            </div>
                        </div>

                        <div class="summary-card">
                            <h3>Live Prediction Stream</h3>
                            <div style="overflow:auto; max-height:300px;">
                                <table style="width:100%; border-collapse: collapse;">
                                    <thead>
                                        <tr>
                                            <th style="text-align:left; padding:6px; border-bottom:1px solid #eee;">Time</th>
                                            <th style="text-align:left; padding:6px; border-bottom:1px solid #eee;">Sample ID</th>
                                            <th style="text-align:left; padding:6px; border-bottom:1px solid #eee;">Prediction</th>
                                            <th style="text-align:left; padding:6px; border-bottom:1px solid #eee;">Confidence</th>
                                            <th style="text-align:left; padding:6px; border-bottom:1px solid #eee;">Temperature</th>
                                            <th style="text-align:left; padding:6px; border-bottom:1px solid #eee;">Pressure</th>
                                            <th style="text-align:left; padding:6px; border-bottom:1px solid #eee;">Humidity</th>
                                        </tr>
                                    </thead>
                                    <tbody id="simulationTable"></tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                `;

                this.initializeSimulationListeners();
            }

            initializeModelTrainingListeners() {
                const trainModelBtn = document.getElementById('trainModelBtn');
                const nextBtn = document.getElementById('nextBtn');
                
                trainModelBtn.addEventListener('click', () => this.trainModel());
                nextBtn.addEventListener('click', () => this.nextStep());
            }

            async trainModel() {
                const trainModelBtn = document.getElementById('trainModelBtn');
                const trainingResults = document.getElementById('trainingResults');
                
                // Disable button and show loading state
                trainModelBtn.disabled = true;
                trainModelBtn.textContent = 'Training...';
                trainModelBtn.style.background = '#6c757d';
                
                try {
                    // Call the .NET backend API to train the model with selected ranges
                    const response = await fetch('http://localhost:5000/api/training/train-model', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify((() => {
                            const combine = (dateStr, timeStr) => new Date(`${dateStr}T${(timeStr||'00:00')}:00`);
                            return {
                                trainStart: combine(this.dateRanges.training.start, this.dateRanges.training.startTime),
                                trainEnd: combine(this.dateRanges.training.end, this.dateRanges.training.endTime),
                                testStart: combine(this.dateRanges.testing.start, this.dateRanges.testing.startTime),
                                testEnd: combine(this.dateRanges.testing.end, this.dateRanges.testing.endTime)
                            };
                        })())
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const results = await response.json();
                
                // Show results
                    this.displayTrainingResults(results);
                    trainingResults.classList.remove('hidden');
                    
                    // Update button
                    trainModelBtn.textContent = 'Model Trained';
                    trainModelBtn.style.background = '#28a745';
                    
                    // Enable next button
                    document.getElementById('nextBtn').disabled = false;
                    
                } catch (error) {
                    console.error('Error training model:', error);
                    alert('Training failed: ' + error.message);
                    trainModelBtn.disabled = false;
                    trainModelBtn.textContent = 'Train Model';
                    trainModelBtn.style.background = '#007bff';
                }
            }

            // removed mock training generators

            displayTrainingResults(results) {
                // Display metrics
                const metricsGrid = document.getElementById('metricsGrid');
                const acc = (results.accuracy ?? results.Accuracy ?? 0);
                const prec = (results.precision ?? results.Precision ?? 0);
                const rec = (results.recall ?? results.Recall ?? 0);
                const f1 = (results.f1Score ?? results.F1Score ?? 0);
                metricsGrid.innerHTML = `
                    <div class="metric-card accuracy">
                        <div class="metric-value">${(acc * 100).toFixed(1)}%</div>
                        <div class="metric-label">Accuracy</div>
                    </div>
                    <div class="metric-card precision">
                        <div class="metric-value">${(prec * 100).toFixed(1)}%</div>
                        <div class="metric-label">Precision</div>
                    </div>
                    <div class="metric-card recall">
                        <div class="metric-value">${(rec * 100).toFixed(1)}%</div>
                        <div class="metric-label">Recall</div>
                    </div>
                    <div class="metric-card f1-score">
                        <div class="metric-value">${(f1 * 100).toFixed(1)}%</div>
                        <div class="metric-label">F1-Score</div>
                    </div>
                `;
                
                // Update training info with real data
                const trainingInfo = document.getElementById('trainingInfo');
                if (results.status === 'Success') {
                    // Get the actual data sizes from the stored dataset
                    const dataset = this.dataset;
                    if (dataset && dataset.rows) {
                        const totalRecords = dataset.rows.length;
                        const trainSize = Math.floor(totalRecords * 0.7); // 70% for training
                        const testSize = totalRecords - trainSize;
                        
                        trainingInfo.textContent = `*Model trained on ${trainSize} records - Validation on ${testSize} records - Results based on actual ML training`;
                    } else {
                        trainingInfo.textContent = `*Model trained successfully - Results based on actual ML training`;
                    }
                } else {
                    trainingInfo.textContent = `*Training completed with fallback data`;
                }
                
                // Render charts if available
                setTimeout(() => {
                    const trainingChartB64 = results.trainingChartBase64 || results.TrainingChartBase64;
                    const confusionMatrixB64 = results.confusionMatrixBase64 || results.ConfusionMatrixBase64;
                    const cmCounts = results.confusionMatrix || results.ConfusionMatrix;

                    if (trainingChartB64) {
                        this.renderTrainingChartFromBase64(trainingChartB64);
                    } else {
                        this.renderTrainingChart(results);
                    }
                    
                    // Prefer structured counts for donut; fall back to image
                    if (cmCounts) {
                        this.renderConfusionMatrix(cmCounts);
                    } else if (confusionMatrixB64) {
                        this.renderConfusionMatrixFromBase64(confusionMatrixB64);
                    }
                }, 100);
            }

            renderTrainingChart(results) {
                const ctx = document.getElementById('trainingChart').getContext('2d');
                
                if (this.trainingChart) {
                    this.trainingChart.destroy();
                }
                
                const epochs = results.trainingAccuracy?.map(d => d.epoch) || [];
                const trainingAcc = results.trainingAccuracy?.map(d => d.training) || [];
                const validationAcc = results.trainingAccuracy?.map(d => d.validation) || [];
                const trainingLoss = results.trainingLoss?.map(d => d.training) || [];
                const validationLoss = results.trainingLoss?.map(d => d.validation) || [];
                
                this.trainingChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: epochs,
                        datasets: [
                            {
                                label: 'Training Accuracy',
                                data: trainingAcc,
                                borderColor: '#28a745',
                                backgroundColor: 'rgba(40, 167, 69, 0.1)',
                                tension: 0.4,
                                yAxisID: 'y'
                            },
                            {
                                label: 'Validation Accuracy',
                                data: validationAcc,
                                borderColor: '#17a2b8',
                                backgroundColor: 'rgba(23, 162, 184, 0.1)',
                                tension: 0.4,
                                yAxisID: 'y'
                            },
                            {
                                label: 'Training Loss',
                                data: trainingLoss,
                                borderColor: '#dc3545',
                                backgroundColor: 'rgba(220, 53, 69, 0.1)',
                                tension: 0.4,
                                yAxisID: 'y1'
                            },
                            {
                                label: 'Validation Loss',
                                data: validationLoss,
                                borderColor: '#fd7e14',
                                backgroundColor: 'rgba(253, 126, 20, 0.1)',
                                tension: 0.4,
                                yAxisID: 'y1'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Epoch'
                                }
                            },
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'Accuracy'
                                },
                                min: 0.5,
                                max: 1.0
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'Loss'
                                },
                                min: 0,
                                max: 1.5,
                                grid: {
                                    drawOnChartArea: false,
                                },
                            }
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            }
                        }
                    }
                });
            }

            renderConfusionMatrix(matrix) {
                const ctx = document.getElementById('confusionChart').getContext('2d');
                
                if (this.confusionChart) {
                    this.confusionChart.destroy();
                }
                
                const total = matrix.truePositive + matrix.falsePositive + matrix.trueNegative + matrix.falseNegative;
                
                this.confusionChart = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: ['True Positive', 'False Positive', 'True Negative', 'False Negative'],
                        datasets: [{
                            data: [matrix.truePositive, matrix.falsePositive, matrix.trueNegative, matrix.falseNegative],
                            backgroundColor: [
                                '#28a745',  // Green for True Positive
                                '#ffc107',  // Yellow for False Positive
                                '#17a2b8',  // Blue for True Negative
                                '#dc3545'   // Red for False Negative
                            ],
                            borderWidth: 2,
                            borderColor: '#ffffff'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'right'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const value = context.raw;
                                        const percentage = ((value / total) * 100).toFixed(1);
                                        return `${context.label}: ${value} (${percentage}%)`;
                                    }
                                }
                            }
                        }
                    }
                });
            }

            initializeDateRangeListeners() {
                const validateBtn = document.getElementById('validateBtn');
                const nextBtn = document.getElementById('nextBtn');
                
                // Date input listeners
                const dateInputs = document.querySelectorAll('.date-input');
                dateInputs.forEach(input => {
                    input.addEventListener('change', () => {
                        this.updateDateRanges();
                        this.isValidated = false;
                        document.getElementById('nextBtn').disabled = true;
                        this.hideValidationResults();
                    });
                });
                // also watch time inputs
                const timeInputs = document.querySelectorAll('input[type="time"]');
                timeInputs.forEach(input => {
                    input.addEventListener('change', () => {
                        this.updateDateRanges();
                        this.isValidated = false;
                        document.getElementById('nextBtn').disabled = true;
                        this.hideValidationResults();
                    });
                });

                validateBtn.addEventListener('click', () => this.validateDateRanges());
                nextBtn.addEventListener('click', () => this.nextStep());
            }

            updateDateRanges() {
                this.dateRanges.training.start = document.getElementById('trainingStart').value;
                this.dateRanges.training.end = document.getElementById('trainingEnd').value;
                this.dateRanges.training.startTime = document.getElementById('trainingStartTime').value;
                this.dateRanges.training.endTime = document.getElementById('trainingEndTime').value;
                this.dateRanges.testing.start = document.getElementById('testingStart').value;
                this.dateRanges.testing.end = document.getElementById('testingEnd').value;
                this.dateRanges.testing.startTime = document.getElementById('testingStartTime').value;
                this.dateRanges.testing.endTime = document.getElementById('testingEndTime').value;
                this.dateRanges.simulation.start = document.getElementById('simulationStart').value;
                this.dateRanges.simulation.end = document.getElementById('simulationEnd').value;
                this.dateRanges.simulation.startTime = document.getElementById('simulationStartTime').value;
                this.dateRanges.simulation.endTime = document.getElementById('simulationEndTime').value;
            }

            async validateDateRanges() {
                this.updateDateRanges();
                const messageDiv = document.getElementById('validationMessage');
                
                try {
                    const combine = (dateStr, timeStr) => new Date(`${dateStr}T${(timeStr||'00:00')}:00`);
                    const body = {
                        trainStart: combine(this.dateRanges.training.start, this.dateRanges.training.startTime),
                        trainEnd: combine(this.dateRanges.training.end, this.dateRanges.training.endTime),
                        testStart: combine(this.dateRanges.testing.start, this.dateRanges.testing.startTime),
                        testEnd: combine(this.dateRanges.testing.end, this.dateRanges.testing.endTime),
                        simStart: combine(this.dateRanges.simulation.start, this.dateRanges.simulation.startTime),
                        simEnd: combine(this.dateRanges.simulation.end, this.dateRanges.simulation.endTime)
                    };

                    const response = await fetch('http://localhost:5000/api/dateranges/validate', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(body)
                    });

                    const data = await response.json();

                    if (!response.ok || data.status !== 'Valid') {
                        throw new Error(data.message || 'Invalid ranges');
                    }

                    // Save daily counts for timeline
                    this.dailyCounts = data.dailyCounts || [];

                    messageDiv.innerHTML = `
                        <div class="validation-message success">
                            <span class="icon">✓</span>
                            Date ranges validated successfully!
                        </div>
                    `;
                    this.isValidated = true;
                    document.getElementById('nextBtn').disabled = false;
                    this.showValidationResults();
                    this.renderTimelineChart();
                } catch (err) {
                    messageDiv.innerHTML = `
                        <div class="validation-message error">
                            <span class="icon">⚠</span>
                            ${err.message}
                        </div>
                    `;
                    this.isValidated = false;
                    this.hideValidationResults();
                }
            }

            performDateValidation() {
                const errors = [];
                const ranges = this.dateRanges;

                // Check if all dates are filled
                Object.keys(ranges).forEach(period => {
                    if (!ranges[period].start || !ranges[period].end) {
                        errors.push(`${period.charAt(0).toUpperCase() + period.slice(1)} period dates are required.`);
                    }
                });

                if (errors.length > 0) {
                    return { isValid: false, errors };
                }

                // Date validation logic
                const trainingStart = new Date(ranges.training.start);
                const trainingEnd = new Date(ranges.training.end);
                const testingStart = new Date(ranges.testing.start);
                const testingEnd = new Date(ranges.testing.end);
                const simulationStart = new Date(ranges.simulation.start);
                const simulationEnd = new Date(ranges.simulation.end);

                // Check start date <= end date for each period
                if (trainingStart >= trainingEnd) {
                    errors.push('Training period start date must be earlier than end date.');
                }
                if (testingStart >= testingEnd) {
                    errors.push('Testing period start date must be earlier than end date.');
                }
                if (simulationStart >= simulationEnd) {
                    errors.push('Simulation period start date must be earlier than end date.');
                }

                // Check sequential ordering
                if (testingStart <= trainingEnd) {
                    errors.push('Testing period must begin after training period ends.');
                }
                if (simulationStart <= testingEnd) {
                    errors.push('Simulation period must begin after testing period ends.');
                }

                return { isValid: errors.length === 0, errors };
            }

            showValidationResults() {
                const summarySection = document.getElementById('rangeSummarySection');
                const summaryCards = document.getElementById('rangeSummaryCards');
                
                const ranges = this.dateRanges;
                let summaryHTML = '';

                Object.keys(ranges).forEach(period => {
                    const start = new Date(ranges[period].start);
                    const end = new Date(ranges[period].end);
                    const duration = Math.ceil((end - start) / (1000 * 60 * 60 * 24));
                    
                    summaryHTML += `
                        <div class="range-summary-card">
                            <h4>${period.charAt(0).toUpperCase() + period.slice(1)} Period</h4>
                            <div class="duration">${duration} days</div>
                            <div class="dates">${ranges[period].start} to ${ranges[period].end}</div>
                        </div>
                    `;
                });

                summaryCards.innerHTML = summaryHTML;
                summarySection.style.display = 'block';
            }

            hideValidationResults() {
                document.getElementById('rangeSummarySection').style.display = 'none';
                document.getElementById('timelineChart').style.display = 'none';
            }

            renderTimelineChart() {
                const chartContainer = document.getElementById('timelineChart');
                chartContainer.style.display = 'block';
                
                const ctx = document.getElementById('timelineCanvas').getContext('2d');
                
                // Destroy existing chart if it exists
                if (this.timelineChart) {
                    this.timelineChart.destroy();
                }

                // Prepare data for timeline chart
                const chartData = this.prepareTimelineData();
                
                this.timelineChart = new Chart(ctx, {
                    type: 'bar',
                    data: chartData,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Month (2021)'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Data Volume (Records)'
                                },
                                beginAtZero: true
                            }
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false
                            }
                        }
                    }
                });
            }

            prepareTimelineData() {
                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                               'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                
                const trainingData = new Array(12).fill(0);
                const testingData = new Array(12).fill(0);
                const simulationData = new Array(12).fill(0);

                // Calculate data volumes per month for each period based on backend daily counts
                (this.dailyCounts || []).forEach(record => {
                    const date = new Date(record.date);
                    const month = date.getMonth();
                    const count = record.records || 0;
                    
                    if (this.isDateInRange(record.date, this.dateRanges.training)) {
                        trainingData[month] += count;
                    } else if (this.isDateInRange(record.date, this.dateRanges.testing)) {
                        testingData[month] += count;
                    } else if (this.isDateInRange(record.date, this.dateRanges.simulation)) {
                        simulationData[month] += count;
                    }
                });

                return {
                    labels: months,
                    datasets: [
                        {
                            label: 'Training Period',
                            data: trainingData,
                            backgroundColor: 'rgba(40, 167, 69, 0.8)',
                            borderColor: 'rgba(40, 167, 69, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'Testing Period',
                            data: testingData,
                            backgroundColor: 'rgba(255, 193, 7, 0.8)',
                            borderColor: 'rgba(255, 193, 7, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'Simulation Period',
                            data: simulationData,
                            backgroundColor: 'rgba(0, 123, 255, 0.8)',
                            borderColor: 'rgba(0, 123, 255, 1)',
                            borderWidth: 1
                        }
                    ]
                };
            }

            isDateInRange(dateString, range) {
                if (!range.start || !range.end) return false;
                const date = new Date(dateString);
                const start = new Date(range.start);
                const end = new Date(range.end);
                return date >= start && date <= end;
            }

            initializeSimulationListeners() {
                const startSimulationBtn = document.getElementById('startSimulationBtn');
                startSimulationBtn.addEventListener('click', () => this.startSimulation());
            }

            async startSimulation() {
                const btn = document.getElementById('startSimulationBtn');
                btn.disabled = true;
                btn.textContent = 'Running...';

                // fetch rows for simulation period
                const response = await fetch('http://localhost:5000/api/simulation/run', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        start: new Date(this.dateRanges.simulation.start),
                        end: new Date(this.dateRanges.simulation.end)
                    })
                });

                const data = await response.json();
                if (!response.ok || data.Status === 'Invalid' || data.status === 'Invalid') {
                    alert(data.message || data.Message || 'Simulation failed');
                    btn.disabled = false;
                    btn.textContent = 'Start Simulation';
                    return;
                }

                const rows = data.rows || data.Rows || [];

                // initialize charts
                const qctx = document.getElementById('qualityChart').getContext('2d');
                if (this.qualityChart) this.qualityChart.destroy();
                this.qualityChart = new Chart(qctx, { type: 'line', data: { labels: [], datasets: [{ label: 'Quality (Confidence %)', data: [], borderColor: '#28a745', backgroundColor: 'rgba(40,167,69,0.1)', tension: 0.4 }] }, options: { responsive: true, maintainAspectRatio: false, scales: { y: { min: 0, max: 100 } } } });

                const cctx = document.getElementById('confidenceChart').getContext('2d');
                if (this.confidenceChart) this.confidenceChart.destroy();
                this.confidenceChart = new Chart(cctx, { type: 'doughnut', data: { labels: ['Pass','Fail'], datasets: [{ data: [0,0], backgroundColor: ['#28a745','#dc3545'] }] }, options: { responsive: true, maintainAspectRatio: false } });

                // stats
                let pass = 0, fail = 0, total = 0, avg = 0;
                const tbody = document.getElementById('simulationTable');
                tbody.innerHTML = '';

                const updateStats = () => {
                    document.getElementById('statTotal').textContent = String(total);
                    document.getElementById('statPass').textContent = String(pass);
                    document.getElementById('statFail').textContent = String(fail);
                    document.getElementById('statAvg').textContent = `${avg.toFixed(1)}%`;
                };

                // stream rows at 1/sec
                let idx = 0;
                const tick = () => {
                    if (idx >= rows.length) {
                        clearInterval(this.simulationInterval);
                        document.getElementById('simulationStatus').classList.remove('hidden');
                        btn.disabled = false;
                        btn.textContent = 'Restart Simulation';
                        return;
                    }
                    const r = rows[idx++];
                    const time = r.timestamp || r.Timestamp || '';
                    const sampleId = r.sample_id || r.sampleId || r.SampleId || '';
                    const pred = r.prediction || r.Prediction || '';
                    const conf = Number(r.confidence ?? r.Confidence ?? 0);
                    const t = r.temperature ?? r.Temperature ?? '';
                    const p = r.pressure ?? r.Pressure ?? '';
                    const h = r.humidity ?? r.Humidity ?? '';

                    // table
                    const tr = document.createElement('tr');
                    tr.innerHTML = `<td style="padding:6px; border-bottom:1px solid #f1f1f1;">${time}</td>
                                    <td style="padding:6px; border-bottom:1px solid #f1f1f1;">${sampleId}</td>
                                    <td style="padding:6px; border-bottom:1px solid #f1f1f1;">${pred}</td>
                                    <td style="padding:6px; border-bottom:1px solid #f1f1f1;">${conf.toFixed(1)}%</td>
                                    <td style="padding:6px; border-bottom:1px solid #f1f1f1;">${t}</td>
                                    <td style="padding:6px; border-bottom:1px solid #f1f1f1;">${p}</td>
                                    <td style="padding:6px; border-bottom:1px solid #f1f1f1;">${h}</td>`;
                    tbody.appendChild(tr);

                    // charts
                    this.qualityChart.data.labels.push(total + 1);
                    this.qualityChart.data.datasets[0].data.push(conf);
                    this.qualityChart.update('none');

                    if (pred === 'Pass') { pass++; this.confidenceChart.data.datasets[0].data[0] = pass; }
                    else { fail++; this.confidenceChart.data.datasets[0].data[1] = fail; }
                    this.confidenceChart.update('none');

                    total++;
                    avg = ((avg * (total - 1)) + conf) / total;
                    updateStats();
                };

                updateStats();
                this.simulationInterval = setInterval(tick, 1000);
            }

            initializeSimulationCharts() {
                this.initializeQualityChart();
                this.initializeConfidenceChart();
            }

            // ... add all the other simulation methods here ...

            renderPlaceholderStep(content) {
                content.innerHTML = `
                    <div class="step-title">Coming Soon</div>
                    <div class="step-counter">Step ${this.currentStep + 1} of 4</div>
                    
                    <div style="text-align: center; padding: 60px;">
                        <h3>This step is under development</h3>
                        <p>Please check back later for updates.</p>
                    </div>
                `;
            }

            renderTrainingChartFromBase64(base64Data) {
                const chartContainer = document.getElementById('trainingChart').parentElement;
                chartContainer.innerHTML = `<img src="data:image/png;base64,${base64Data}" style="width: 100%; height: auto;" alt="Training Chart">`;
            }

            renderConfusionMatrixFromBase64(base64Data) {
                const chartContainer = document.getElementById('confusionChart').parentElement;
                chartContainer.innerHTML = `<img src="data:image/png;base64,${base64Data}" style="width: 100%; height: auto;" alt="Confusion Matrix">`;
            }

                        

            nextStep() {
                if (this.currentStep < 3) {
                    this.currentStep++;
                    this.updateStepDisplay();
                    this.renderStep();
                }
            }
        }

        // Initialize the application
        let app;
        document.addEventListener('DOMContentLoaded', () => {
            app = new MiniMLApp();
        });
    </script>
</body>
</html>