<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MiniML - Predictive Quality Control</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/rxjs/7.8.1/rxjs.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f7fa;
            color: #333;
        }

        .header {
            background: linear-gradient(135deg, #ff4444 0%, #cc3366 50%, #9966cc 100%);
            color: white;
            padding: 16px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 18px;
            font-weight: 500;
        }

        .header .subtitle {
            font-size: 12px;
            opacity: 0.9;
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            letter-spacing: -1px;
        }

        .progress-container {
            background: white;
            padding: 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .step-indicator {
            display: flex;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }

        .step {
            flex: 1;
            display: flex;
            align-items: center;
            padding: 12px 16px;
            border-right: 1px solid #e9ecef;
            font-size: 14px;
            position: relative;
        }

        .step:last-child {
            border-right: none;
        }

        .step.active {
            background: #e8f5e8;
            color: #2d5a2d;
        }

        .step.disabled {
            color: #999;
        }

        .step-number {
            background: #28a745;
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 8px;
            font-size: 12px;
            font-weight: bold;
        }

        .step.disabled .step-number {
            background: #ccc;
        }

        .current-step {
            background: white;
            padding: 24px;
            min-height: 500px;
        }

        .step-title {
            color: #666;
            font-size: 14px;
            margin-bottom: 8px;
        }

        .step-counter {
            background: #007bff;
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
            float: right;
        }

        .upload-area {
            border: 2px dashed #d1d5db;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            background: #fafafa;
            margin: 20px 0;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-area:hover {
            border-color: #007bff;
            background: #f8f9ff;
        }

        .upload-area.dragover {
            border-color: #007bff;
            background: #e8f4ff;
            transform: scale(1.02);
        }

        .upload-icon {
            width: 48px;
            height: 48px;
            margin: 0 auto 16px;
            opacity: 0.5;
        }

        .upload-text {
            color: #666;
            font-size: 16px;
            margin-bottom: 16px;
        }

        .choose-file-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .choose-file-btn:hover {
            background: #0056b3;
        }

        .choose-file-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .file-input {
            display: none;
        }

        .summary-card {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-top: 16px;
        }

        .summary-item {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 6px;
            border-left: 4px solid #007bff;
        }

        .summary-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .summary-value {
            font-size: 16px;
            font-weight: 600;
            color: #333;
        }

        .summary-value.link {
            color: #007bff;
            cursor: pointer;
            text-decoration: underline;
        }

        .next-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 32px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            float: right;
            margin-top: 20px;
            transition: background 0.3s ease;
        }

        .next-btn:hover:not(:disabled) {
            background: #0056b3;
        }

        .next-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        /* Date Ranges Screen Styles */
        .date-ranges-container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .periods-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .period-card {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .period-card h3 {
            color: #333;
            font-size: 16px;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
        }

        .period-icon {
            width: 20px;
            height: 20px;
            margin-right: 8px;
            border-radius: 3px;
        }

        .period-icon.training {
            background: #28a745;
        }

        .period-icon.testing {
            background: #ffc107;
        }

        .period-icon.simulation {
            background: #007bff;
        }

        .date-input-group {
            margin-bottom: 12px;
        }

        .date-input-group label {
            display: block;
            font-size: 12px;
            color: #666;
            margin-bottom: 4px;
            text-transform: uppercase;
        }

        .date-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .date-input:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
        }

        .validation-message {
            margin: 20px 0;
            padding: 12px;
            border-radius: 6px;
            font-size: 14px;
        }

        .validation-message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .validation-message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .validation-message .icon {
            margin-right: 8px;
        }

        .range-summary-section {
            margin: 30px 0;
        }

        .range-summary-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 16px;
            margin: 16px 0;
        }

        .range-summary-card {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 16px;
            text-align: center;
        }

        .range-summary-card h4 {
            color: #666;
            font-size: 12px;
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .range-summary-card .duration {
            font-size: 24px;
            font-weight: bold;
            color: #333;
            margin-bottom: 4px;
        }

        .range-summary-card .dates {
            font-size: 12px;
            color: #666;
        }

        .timeline-chart-container {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .timeline-chart-container h3 {
            margin-bottom: 16px;
            color: #333;
            font-size: 16px;
        }

        .chart-container {
            position: relative;
            height: 300px;
        }

        .action-buttons {
            margin-top: 30px;
            text-align: right;
        }

        .validate-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            margin-right: 12px;
            transition: background 0.3s ease;
        }

        .validate-btn:hover {
            background: #218838;
        }

        .validate-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .footer {
            background: linear-gradient(135deg, #ff4444 0%, #9966cc 100%);
            color: white;
            text-align: center;
            padding: 12px;
            font-size: 12px;
            font-weight: 500;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
        }

        .hidden {
            display: none;
        }
        /* Add these CSS styles to your existing stylesheet */

        /* Model Training Screen Styles */
        .model-training-container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .training-section {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 200px;
            margin: 40px 0;
        }

        .training-button-container {
            text-align: center;
        }

        .train-model-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 16px 40px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,123,255,0.3);
        }

        .train-model-btn:hover:not(:disabled) {
            background: #0056b3;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,123,255,0.4);
        }

        .train-model-btn:disabled {
            cursor: not-allowed;
            transform: none;
        }

        .training-results {
            margin-top: 30px;
        }

        .training-status {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 30px;
            display: flex;
            align-items: center;
            font-weight: 500;
        }

        .status-icon {
            background: #28a745;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            font-size: 14px;
        }

        .metrics-section {
            margin: 30px 0;
        }

        .metrics-section h3 {
            color: #333;
            font-size: 18px;
            margin-bottom: 20px;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 16px;
        }

        .metric-card {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 24px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            position: relative;
            overflow: hidden;
        }

        .metric-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
        }

        .metric-card.accuracy::before {
            background: linear-gradient(90deg, #4c6ef5 0%, #7c3aed 100%);
        }

        .metric-card.precision::before {
            background: linear-gradient(90deg, #ec4899 0%, #f97316 100%);
        }

        .metric-card.recall::before {
            background: linear-gradient(90deg, #06b6d4 0%, #10b981 100%);
        }

        .metric-card.f1-score::before {
            background: linear-gradient(90deg, #10b981 0%, #84cc16 100%);
        }

        .metric-value {
            font-size: 32px;
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
        }

        .metric-label {
            font-size: 14px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .metrics-note {
            font-size: 12px;
            color: #666;
            font-style: italic;
            text-align: center;
            margin-top: 16px;
        }

        .charts-section {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            margin: 30px 0;
        }

        .chart-card {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .chart-card h3 {
            color: #333;
            font-size: 16px;
            margin-bottom: 4px;
        }

        .chart-subtitle {
            color: #666;
            font-size: 14px;
            margin-bottom: 20px;
        }

        .chart-container {
            position: relative;
            height: 300px;
            margin-top: 16px;
        }

        .confusion-matrix-container {
            position: relative;
            height: 300px;
            margin-top: 16px;
        }

        /* Responsive adjustments */
        @media (max-width: 1000px) {
            .charts-section {
                grid-template-columns: 1fr;
            }
            
            .metrics-grid {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            }
        }

        @media (max-width: 768px) {
            .train-model-btn {
                padding: 14px 32px;
                font-size: 14px;
            }
            
            .metric-value {
                font-size: 24px;
            }
            
            .chart-container,
            .confusion-matrix-container {
                height: 250px;
            }
        }
        /* Simulation Screen Styles */
        .simulation-container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .simulation-section {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 200px;
            margin: 40px 0;
        }

/* ... rest of the simulation CSS styles ... */
    </style>
</head>
<body>
    <div id="app">
        <!-- Header -->
        <div class="header">
            <div>
                <h1>MiniML - Predictive Quality Control</h1>
                <div class="subtitle">Simplified Frontend</div>
            </div>
            <div class="logo">ABB</div>
        </div>

        <!-- Progress Steps -->
        <div class="progress-container">
            <div class="step-indicator">
                <div class="step active" data-step="0">
                    <div class="step-number">1</div>
                    <span>Upload Dataset</span>
                </div>
                <div class="step disabled" data-step="1">
                    <div class="step-number">2</div>
                    <span>Date Ranges</span>
                </div>
                <div class="step disabled" data-step="2">
                    <div class="step-number">3</div>
                    <span>Model Training</span>
                </div>
                <div class="step disabled" data-step="3">
                    <div class="step-number">4</div>
                    <span>Simulation</span>
                </div>
            </div>
        </div>

        <!-- Current Step Content -->
        <div class="current-step" id="currentStepContent">
            <!-- Step 1 content will be here initially -->
        </div>

        <!-- Footer -->
        <div class="footer">
            ENGINEERED TO OUTRUN
        </div>
    </div>

    <script>
        class MiniMLApp {
            constructor() {
                this.currentStep = 0;
                this.uploadedFile = null;
                this.fileData = null;
                this.trainingChart = null;
                this.confusionChart = null;
                this.qualityChart = null;
                this.confidenceChart = null;
                this.simulationInterval = null;
                this.qualityData = null;
                this.confidenceData = null;
                this.simulationStats = null;
                this.dateRanges = {
                    training: { start: '', end: '' },
                    testing: { start: '', end: '' },
                    simulation: { start: '', end: '' }
                };
                this.isValidated = false;
                this.mockDataset = this.generateMockDataset();
                this.initializeApp();
            }

            generateMockDataset() {
                // Generate mock dataset with dates from 2021
                const startDate = new Date('2021-01-01');
                const endDate = new Date('2021-12-31');
                const data = [];
                
                for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
                    // Add some variation in record counts per day
                    const recordCount = Math.floor(Math.random() * 100) + 50;
                    data.push({
                        date: new Date(d).toISOString().split('T')[0],
                        recordCount: recordCount
                    });
                }
                
                return data;
            }

            initializeApp() {
                this.renderStep();
                this.initializeStepIndicators();
            }

            initializeStepIndicators() {
                const steps = document.querySelectorAll('.step');
                steps.forEach((step, index) => {
                    step.addEventListener('click', () => {
                        if (index <= this.currentStep || (index === 1 && this.uploadedFile)) {
                            this.currentStep = index;
                            this.updateStepDisplay();
                            this.renderStep();
                        }
                    });
                });
            }

            updateStepDisplay() {
                const steps = document.querySelectorAll('.step');
                steps.forEach((step, index) => {
                    step.classList.remove('active', 'disabled');
                    if (index === this.currentStep) {
                        step.classList.add('active');
                    } else if (index > this.currentStep && !(index === 1 && this.uploadedFile)) {
                        step.classList.add('disabled');
                    }
                });
            }

            renderStep() {
                const content = document.getElementById('currentStepContent');
                
                switch (this.currentStep) {
                    case 0:
                        this.renderUploadStep(content);
                        break;
                    case 1:
                        this.renderDateRangesStep(content);
                        break;
                    case 2:
                        this.renderModelTrainingStep(content);
                        break;
                    case 3:
                        this.renderSimulationStep(content);
                        break;
                    default:
                        this.renderPlaceholderStep(content);
                        break;
                }
            }

            renderUploadStep(content) {
                content.innerHTML = `
                    <div class="step-title">Upload Dataset</div>
                    <div class="step-counter">Step 1 of 4</div>
                    
                    <div class="upload-area" id="uploadArea">
                        <svg class="upload-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M14 2H6C4.9 2 4 2.9 4 4V20C4 21.1 4.9 22 6 22H18C19.1 22 20 21.1 20 20V8L14 2Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <polyline points="14,2 14,8 20,8" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <line x1="16" y1="13" x2="8" y2="13" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <line x1="16" y1="17" x2="8" y2="17" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <polyline points="10,9 9,9 9,10" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                        <div class="upload-text">Click to select a CSV file or drag and drop</div>
                        <button class="choose-file-btn" id="chooseFileBtn">Choose File</button>
                        <input type="file" class="file-input" id="fileInput" accept=".csv">
                    </div>

                    <div class="summary-card hidden" id="summaryCard">
                        <h3>Post-upload Info Summary Card</h3>
                        <div class="summary-grid" id="summaryGrid"></div>
                    </div>

                    <button class="next-btn" id="nextBtn" ${!this.uploadedFile ? 'disabled' : ''}>Next</button>
                `;

                this.initializeUploadListeners();
            }

            initializeUploadListeners() {
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');
                const chooseFileBtn = document.getElementById('chooseFileBtn');
                const nextBtn = document.getElementById('nextBtn');

                fileInput.addEventListener('change', (e) => this.handleFileSelect(e));
                chooseFileBtn.addEventListener('click', () => fileInput.click());
                uploadArea.addEventListener('dragover', (e) => this.handleDragOver(e));
                uploadArea.addEventListener('dragleave', (e) => this.handleDragLeave(e));
                uploadArea.addEventListener('drop', (e) => this.handleDrop(e));
                uploadArea.addEventListener('click', () => fileInput.click());
                nextBtn.addEventListener('click', () => this.nextStep());
            }

            handleDragOver(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.add('dragover');
            }

            handleDragLeave(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.remove('dragover');
            }

            handleDrop(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0 && files[0].type === 'text/csv') {
                    this.processFile(files[0]);
                }
            }

            handleFileSelect(e) {
                const file = e.target.files[0];
                if (file) {
                    this.processFile(file);
                }
            }

            processFile(file) {
                this.uploadedFile = file;
                
                setTimeout(() => {
                    this.showSummaryCard(file);
                    document.getElementById('nextBtn').disabled = false;
                }, 1000);
            }

            showSummaryCard(file) {
                const summaryCard = document.getElementById('summaryCard');
                const summaryGrid = document.getElementById('summaryGrid');
                
                const mockData = this.generateMockSummary(file);
                
                summaryGrid.innerHTML = `
                    <div class="summary-item">
                        <div class="summary-label">File Name</div>
                        <div class="summary-value link">${file.name}</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-label">Total Records</div>
                        <div class="summary-value">${mockData.totalRecords}</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-label">Total Columns</div>
                        <div class="summary-value">${mockData.totalColumns}</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-label">Pass Rate</div>
                        <div class="summary-value">${mockData.passRate}</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-label">Date Range</div>
                        <div class="summary-value">${mockData.dateRange}</div>
                    </div>
                `;
                
                summaryCard.classList.remove('hidden');
            }

            generateMockSummary(file) {
                const records = Math.floor(Math.random() * 50000) + 10000;
                const columns = Math.floor(Math.random() * 20) + 5;
                const passRate = (Math.random() * 30 + 70).toFixed(1) + '%';
                const dateRange = '2021-01-01 to 2021-12-31';
                
                return {
                    totalRecords: records.toLocaleString(),
                    totalColumns: columns.toString(),
                    passRate: passRate,
                    dateRange: dateRange
                };
            }

            renderDateRangesStep(content) {
                content.innerHTML = `
                    <div class="step-title">Date Ranges</div>
                    <div class="step-counter">Step 2 of 4</div>
                    
                    <div class="date-ranges-container">
                        <div class="periods-grid">
                            <div class="period-card">
                                <h3><div class="period-icon training"></div>Training Period</h3>
                                <div class="date-input-group">
                                    <label>Start Date</label>
                                    <input type="date" class="date-input" id="trainingStart" min="2021-01-01" max="2021-12-31" value="${this.dateRanges.training.start}">
                                </div>
                                <div class="date-input-group">
                                    <label>End Date</label>
                                    <input type="date" class="date-input" id="trainingEnd" min="2021-01-01" max="2021-12-31" value="${this.dateRanges.training.end}">
                                </div>
                            </div>
                            
                            <div class="period-card">
                                <h3><div class="period-icon testing"></div>Testing Period</h3>
                                <div class="date-input-group">
                                    <label>Start Date</label>
                                    <input type="date" class="date-input" id="testingStart" min="2021-01-01" max="2021-12-31" value="${this.dateRanges.testing.start}">
                                </div>
                                <div class="date-input-group">
                                    <label>End Date</label>
                                    <input type="date" class="date-input" id="testingEnd" min="2021-01-01" max="2021-12-31" value="${this.dateRanges.testing.end}">
                                </div>
                            </div>
                            
                            <div class="period-card">
                                <h3><div class="period-icon simulation"></div>Simulation Period</h3>
                                <div class="date-input-group">
                                    <label>Start Date</label>
                                    <input type="date" class="date-input" id="simulationStart" min="2021-01-01" max="2021-12-31" value="${this.dateRanges.simulation.start}">
                                </div>
                                <div class="date-input-group">
                                    <label>End Date</label>
                                    <input type="date" class="date-input" id="simulationEnd" min="2021-01-01" max="2021-12-31" value="${this.dateRanges.simulation.end}">
                                </div>
                            </div>
                        </div>
                        
                        <div id="validationMessage"></div>
                        
                        <div class="range-summary-section" id="rangeSummarySection" style="display: none;">
                            <h3>Selected Date Ranges Summary</h3>
                            <div class="range-summary-cards" id="rangeSummaryCards"></div>
                        </div>
                        
                        <div class="timeline-chart-container" id="timelineChart" style="display: none;">
                            <h3>Timeline Summary</h3>
                            <div class="chart-container">
                                <canvas id="timelineCanvas"></canvas>
                            </div>
                        </div>
                        
                        <div class="action-buttons">
                            <button class="validate-btn" id="validateBtn">Validate Ranges</button>
                            <button class="next-btn" id="nextBtn" ${!this.isValidated ? 'disabled' : ''}>Next</button>
                        </div>
                    </div>
                `;

                this.initializeDateRangeListeners();
            }

            // Add this method to your MiniMLApp class, replacing the renderPlaceholderStep method

            renderModelTrainingStep(content) {
                content.innerHTML = `
                    <div class="step-title">Model Training & Evaluation</div>
                    <div class="step-counter">Step 3 of 4</div>
                    
                    <div class="model-training-container">
                        <div class="training-section" id="trainingSection">
                            <div class="training-button-container">
                                <button class="train-model-btn" id="trainModelBtn">Train Model</button>
                            </div>
                        </div>
                        
                        <div class="training-results hidden" id="trainingResults">
                            <div class="training-status" id="trainingStatus">
                                <div class="status-icon">✓</div>
                                <span>Model Trained Successfully!</span>
                            </div>
                            
                            <div class="metrics-section">
                                <h3>Model Performance Metrics</h3>
                                <div class="metrics-grid" id="metricsGrid">
                                    <!-- Metrics will be populated here -->
                                </div>
                                <div class="metrics-note">
                                    *Model trained on 6 months of data - Validation on 2 months - Results based on 1 month simulation
                                </div>
                            </div>
                            
                            <div class="charts-section">
                                <div class="chart-card">
                                    <h3>Model Performance</h3>
                                    <div class="chart-subtitle">Training Metrics</div>
                                    <div class="chart-container">
                                        <canvas id="trainingChart"></canvas>
                                    </div>
                                </div>
                                
                                <div class="chart-card">
                                    <h3>Model Performance</h3>
                                    <div class="chart-subtitle">Confusion Matrix</div>
                                    <div class="confusion-matrix-container">
                                        <canvas id="confusionChart"></canvas>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <button class="next-btn" id="nextBtn" disabled>Next</button>
                `;

                this.initializeModelTrainingListeners();
            }

            renderSimulationStep(content) {
                content.innerHTML = `
                    <div class="step-title">Real-Time Prediction Simulation</div>
                    <!-- ... rest of the method ... -->
                `;

                this.initializeSimulationListeners();
            }

            initializeModelTrainingListeners() {
                const trainModelBtn = document.getElementById('trainModelBtn');
                const nextBtn = document.getElementById('nextBtn');
                
                trainModelBtn.addEventListener('click', () => this.trainModel());
                nextBtn.addEventListener('click', () => this.nextStep());
            }

            async trainModel() {
                const trainModelBtn = document.getElementById('trainModelBtn');
                const trainingResults = document.getElementById('trainingResults');
                
                // Disable button and show loading state
                trainModelBtn.disabled = true;
                trainModelBtn.textContent = 'Training...';
                trainModelBtn.style.background = '#6c757d';
                
                // Simulate training delay
                await new Promise(resolve => setTimeout(resolve, 3000));
                
                // Generate mock training results
                const mockResults = this.generateMockTrainingResults();
                
                // Show results
                this.displayTrainingResults(mockResults);
                trainingResults.classList.remove('hidden');
                
                // Update button
                trainModelBtn.textContent = 'Model Trained';
                trainModelBtn.style.background = '#28a745';
                
                // Enable next button
                document.getElementById('nextBtn').disabled = false;
            }

            generateMockTrainingResults() {
                return {
                    accuracy: (Math.random() * 5 + 92).toFixed(1), // 92-97%
                    precision: (Math.random() * 5 + 91).toFixed(1), // 91-96%
                    recall: (Math.random() * 5 + 90).toFixed(1), // 90-95%
                    f1Score: (Math.random() * 5 + 91).toFixed(1), // 91-96%
                    trainingAccuracy: this.generateTrainingCurveData(),
                    trainingLoss: this.generateLossCurveData(),
                    confusionMatrix: {
                        truePositive: Math.floor(Math.random() * 200 + 800),
                        falsePositive: Math.floor(Math.random() * 50 + 20),
                        trueNegative: Math.floor(Math.random() * 100 + 150),
                        falseNegative: Math.floor(Math.random() * 30 + 15)
                    }
                };
            }

            generateTrainingCurveData() {
                const epochs = 20;
                const data = [];
                let accuracy = 0.7;
                
                for (let i = 0; i < epochs; i++) {
                    accuracy += (Math.random() * 0.03 - 0.005); // Gradual improvement with some noise
                    if (accuracy > 0.97) accuracy = 0.97; // Cap at 97%
                    data.push({
                        epoch: i + 1,
                        training: Math.max(0.65, accuracy + (Math.random() * 0.02)),
                        validation: Math.max(0.60, accuracy - (Math.random() * 0.02))
                    });
                }
                
                return data;
            }

            generateLossCurveData() {
                const epochs = 20;
                const data = [];
                let loss = 1.2;
                
                for (let i = 0; i < epochs; i++) {
                    loss -= (Math.random() * 0.05 + 0.02); // Decreasing loss
                    if (loss < 0.1) loss = 0.1; // Minimum loss
                    data.push({
                        epoch: i + 1,
                        training: Math.max(0.08, loss + (Math.random() * 0.05)),
                        validation: Math.max(0.10, loss + (Math.random() * 0.08))
                    });
                }
                
                return data;
            }

            displayTrainingResults(results) {
                // Display metrics
                const metricsGrid = document.getElementById('metricsGrid');
                metricsGrid.innerHTML = `
                    <div class="metric-card accuracy">
                        <div class="metric-value">${results.accuracy}%</div>
                        <div class="metric-label">Accuracy</div>
                    </div>
                    <div class="metric-card precision">
                        <div class="metric-value">${results.precision}%</div>
                        <div class="metric-label">Precision</div>
                    </div>
                    <div class="metric-card recall">
                        <div class="metric-value">${results.recall}%</div>
                        <div class="metric-label">Recall</div>
                    </div>
                    <div class="metric-card f1-score">
                        <div class="metric-value">${results.f1Score}%</div>
                        <div class="metric-label">F1-Score</div>
                    </div>
                `;
                
                // Render charts
                setTimeout(() => {
                    this.renderTrainingChart(results);
                    this.renderConfusionMatrix(results.confusionMatrix);
                }, 100);
            }

            renderTrainingChart(results) {
                const ctx = document.getElementById('trainingChart').getContext('2d');
                
                if (this.trainingChart) {
                    this.trainingChart.destroy();
                }
                
                const epochs = results.trainingAccuracy.map(d => d.epoch);
                const trainingAcc = results.trainingAccuracy.map(d => d.training);
                const validationAcc = results.trainingAccuracy.map(d => d.validation);
                const trainingLoss = results.trainingLoss.map(d => d.training);
                const validationLoss = results.trainingLoss.map(d => d.validation);
                
                this.trainingChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: epochs,
                        datasets: [
                            {
                                label: 'Training Accuracy',
                                data: trainingAcc,
                                borderColor: '#28a745',
                                backgroundColor: 'rgba(40, 167, 69, 0.1)',
                                tension: 0.4,
                                yAxisID: 'y'
                            },
                            {
                                label: 'Validation Accuracy',
                                data: validationAcc,
                                borderColor: '#17a2b8',
                                backgroundColor: 'rgba(23, 162, 184, 0.1)',
                                tension: 0.4,
                                yAxisID: 'y'
                            },
                            {
                                label: 'Training Loss',
                                data: trainingLoss,
                                borderColor: '#dc3545',
                                backgroundColor: 'rgba(220, 53, 69, 0.1)',
                                tension: 0.4,
                                yAxisID: 'y1'
                            },
                            {
                                label: 'Validation Loss',
                                data: validationLoss,
                                borderColor: '#fd7e14',
                                backgroundColor: 'rgba(253, 126, 20, 0.1)',
                                tension: 0.4,
                                yAxisID: 'y1'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Epoch'
                                }
                            },
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'Accuracy'
                                },
                                min: 0.5,
                                max: 1.0
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'Loss'
                                },
                                min: 0,
                                max: 1.5,
                                grid: {
                                    drawOnChartArea: false,
                                },
                            }
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            }
                        }
                    }
                });
            }

            renderConfusionMatrix(matrix) {
                const ctx = document.getElementById('confusionChart').getContext('2d');
                
                if (this.confusionChart) {
                    this.confusionChart.destroy();
                }
                
                const total = matrix.truePositive + matrix.falsePositive + matrix.trueNegative + matrix.falseNegative;
                
                this.confusionChart = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: ['True Positive', 'False Positive', 'True Negative', 'False Negative'],
                        datasets: [{
                            data: [matrix.truePositive, matrix.falsePositive, matrix.trueNegative, matrix.falseNegative],
                            backgroundColor: [
                                '#28a745',  // Green for True Positive
                                '#ffc107',  // Yellow for False Positive
                                '#17a2b8',  // Blue for True Negative
                                '#dc3545'   // Red for False Negative
                            ],
                            borderWidth: 2,
                            borderColor: '#ffffff'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'right'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const value = context.raw;
                                        const percentage = ((value / total) * 100).toFixed(1);
                                        return `${context.label}: ${value} (${percentage}%)`;
                                    }
                                }
                            }
                        }
                    }
                });
            }

            initializeDateRangeListeners() {
                const validateBtn = document.getElementById('validateBtn');
                const nextBtn = document.getElementById('nextBtn');
                
                // Date input listeners
                const dateInputs = document.querySelectorAll('.date-input');
                dateInputs.forEach(input => {
                    input.addEventListener('change', () => {
                        this.updateDateRanges();
                        this.isValidated = false;
                        document.getElementById('nextBtn').disabled = true;
                        this.hideValidationResults();
                    });
                });

                validateBtn.addEventListener('click', () => this.validateDateRanges());
                nextBtn.addEventListener('click', () => this.nextStep());
            }

            updateDateRanges() {
                this.dateRanges.training.start = document.getElementById('trainingStart').value;
                this.dateRanges.training.end = document.getElementById('trainingEnd').value;
                this.dateRanges.testing.start = document.getElementById('testingStart').value;
                this.dateRanges.testing.end = document.getElementById('testingEnd').value;
                this.dateRanges.simulation.start = document.getElementById('simulationStart').value;
                this.dateRanges.simulation.end = document.getElementById('simulationEnd').value;
            }

            validateDateRanges() {
                this.updateDateRanges();
                const validation = this.performDateValidation();
                
                const messageDiv = document.getElementById('validationMessage');
                
                if (validation.isValid) {
                    messageDiv.innerHTML = `
                        <div class="validation-message success">
                            <span class="icon">✓</span>
                            Date ranges validated successfully!
                        </div>
                    `;
                    this.isValidated = true;
                    document.getElementById('nextBtn').disabled = false;
                    this.showValidationResults();
                    this.renderTimelineChart();
                } else {
                    messageDiv.innerHTML = `
                        <div class="validation-message error">
                            <span class="icon">⚠</span>
                            ${validation.errors.join('<br>')}
                        </div>
                    `;
                    this.isValidated = false;
                    this.hideValidationResults();
                }
            }

            performDateValidation() {
                const errors = [];
                const ranges = this.dateRanges;

                // Check if all dates are filled
                Object.keys(ranges).forEach(period => {
                    if (!ranges[period].start || !ranges[period].end) {
                        errors.push(`${period.charAt(0).toUpperCase() + period.slice(1)} period dates are required.`);
                    }
                });

                if (errors.length > 0) {
                    return { isValid: false, errors };
                }

                // Date validation logic
                const trainingStart = new Date(ranges.training.start);
                const trainingEnd = new Date(ranges.training.end);
                const testingStart = new Date(ranges.testing.start);
                const testingEnd = new Date(ranges.testing.end);
                const simulationStart = new Date(ranges.simulation.start);
                const simulationEnd = new Date(ranges.simulation.end);

                // Check start date <= end date for each period
                if (trainingStart >= trainingEnd) {
                    errors.push('Training period start date must be earlier than end date.');
                }
                if (testingStart >= testingEnd) {
                    errors.push('Testing period start date must be earlier than end date.');
                }
                if (simulationStart >= simulationEnd) {
                    errors.push('Simulation period start date must be earlier than end date.');
                }

                // Check sequential ordering
                if (testingStart <= trainingEnd) {
                    errors.push('Testing period must begin after training period ends.');
                }
                if (simulationStart <= testingEnd) {
                    errors.push('Simulation period must begin after testing period ends.');
                }

                return { isValid: errors.length === 0, errors };
            }

            showValidationResults() {
                const summarySection = document.getElementById('rangeSummarySection');
                const summaryCards = document.getElementById('rangeSummaryCards');
                
                const ranges = this.dateRanges;
                let summaryHTML = '';

                Object.keys(ranges).forEach(period => {
                    const start = new Date(ranges[period].start);
                    const end = new Date(ranges[period].end);
                    const duration = Math.ceil((end - start) / (1000 * 60 * 60 * 24));
                    
                    summaryHTML += `
                        <div class="range-summary-card">
                            <h4>${period.charAt(0).toUpperCase() + period.slice(1)} Period</h4>
                            <div class="duration">${duration} days</div>
                            <div class="dates">${ranges[period].start} to ${ranges[period].end}</div>
                        </div>
                    `;
                });

                summaryCards.innerHTML = summaryHTML;
                summarySection.style.display = 'block';
            }

            hideValidationResults() {
                document.getElementById('rangeSummarySection').style.display = 'none';
                document.getElementById('timelineChart').style.display = 'none';
            }

            renderTimelineChart() {
                const chartContainer = document.getElementById('timelineChart');
                chartContainer.style.display = 'block';
                
                const ctx = document.getElementById('timelineCanvas').getContext('2d');
                
                // Destroy existing chart if it exists
                if (this.timelineChart) {
                    this.timelineChart.destroy();
                }

                // Prepare data for timeline chart
                const chartData = this.prepareTimelineData();
                
                this.timelineChart = new Chart(ctx, {
                    type: 'bar',
                    data: chartData,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Month (2021)'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Data Volume (Records)'
                                },
                                beginAtZero: true
                            }
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false
                            }
                        }
                    }
                });
            }

            prepareTimelineData() {
                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                               'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                
                const trainingData = new Array(12).fill(0);
                const testingData = new Array(12).fill(0);
                const simulationData = new Array(12).fill(0);

                // Calculate data volumes per month for each period
                this.mockDataset.forEach(record => {
                    const date = new Date(record.date);
                    const month = date.getMonth();
                    
                    if (this.isDateInRange(record.date, this.dateRanges.training)) {
                        trainingData[month] += record.recordCount;
                    } else if (this.isDateInRange(record.date, this.dateRanges.testing)) {
                        testingData[month] += record.recordCount;
                    } else if (this.isDateInRange(record.date, this.dateRanges.simulation)) {
                        simulationData[month] += record.recordCount;
                    }
                });

                return {
                    labels: months,
                    datasets: [
                        {
                            label: 'Training Period',
                            data: trainingData,
                            backgroundColor: 'rgba(40, 167, 69, 0.8)',
                            borderColor: 'rgba(40, 167, 69, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'Testing Period',
                            data: testingData,
                            backgroundColor: 'rgba(255, 193, 7, 0.8)',
                            borderColor: 'rgba(255, 193, 7, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'Simulation Period',
                            data: simulationData,
                            backgroundColor: 'rgba(0, 123, 255, 0.8)',
                            borderColor: 'rgba(0, 123, 255, 1)',
                            borderWidth: 1
                        }
                    ]
                };
            }

            isDateInRange(dateString, range) {
                if (!range.start || !range.end) return false;
                const date = new Date(dateString);
                const start = new Date(range.start);
                const end = new Date(range.end);
                return date >= start && date <= end;
            }

            initializeSimulationListeners() {
                const startSimulationBtn = document.getElementById('startSimulationBtn');
                startSimulationBtn.addEventListener('click', () => this.startSimulation());
            }

            async startSimulation() {
                // ... full method content ...
            }

            initializeSimulationCharts() {
                this.initializeQualityChart();
                this.initializeConfidenceChart();
            }

            // ... add all the other simulation methods here ...

            renderPlaceholderStep(content) {
                content.innerHTML = `
                    <div class="step-title">Coming Soon</div>
                    <div class="step-counter">Step ${this.currentStep + 1} of 4</div>
                    
                    <div style="text-align: center; padding: 60px;">
                        <h3>This step is under development</h3>
                        <p>Please check back later for updates.</p>
                    </div>
                `;
            }

                        

            nextStep() {
                if (this.currentStep < 3) {
                    this.currentStep++;
                    this.updateStepDisplay();
                    this.renderStep();
                }
            }
        }

        // Initialize the application
        let app;
        document.addEventListener('DOMContentLoaded', () => {
            app = new MiniMLApp();
        });
    </script>
</body>
</html>